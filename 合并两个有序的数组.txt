step1：使用三个指针，i指向数组A的最大元素，j指向数组B的最大元素，k指向数组A空间的结尾处。
step 2：从两个数组最大的元素开始遍历，直到某一个结束，每次取出较大的一个值放入数组A空间的最后，然后指针一次往前。
step 3：如果数组B先遍历结束，数组A前半部分已经存在了，不用管；但是如果数组A先遍历结束，则需要把数组B剩余的前半部分依次逆序加入数组A前半部分，类似归并排序最后的步骤。

class Solution {
  public:
    void merge(int A[], int m, int B[], int n) {
        //指向数组A的结尾
        int i = m - 1;

        //指向数组B的结尾
        int j = n - 1;

        //指向数组A空间的结尾处
        int k = m + n - 1;

        //从两个数组最大的元素开始，直到某一个数组遍历完
        while (i >= 0 && j >= 0) {
            //将较大的元素放到最后
            if (A[i] > B[j])
                A[k--] = A[i--];
            else
                A[k--] = B[j--];
        }
        
        //数组A遍历完了，数组B还有，则还需要添加到数组A前面
        if (i < 0) {
            while (j >= 0)
                A[k--] = B[j--];
        }
        //数组B遍历完了，数组A前面正好有，不用再添加
    }
};